from _typeshed import Incomplete

whitespace: Incomplete
unicode_whitespace: Incomplete
unicode_chrs: Incomplete
punctuation: Incomplete
code_pattern: Incomplete

def find_core_tokens(string, root): ...
def find_link_image(string, offset, delimiters, matches, root: Incomplete | None = ...): ...
def process_emphasis(string, stack_bottom, delimiters, matches) -> None: ...
def match_link_image(string, offset, delimiter, root: Incomplete | None = ...): ...
def match_link_dest(string, offset): ...
def match_link_title(string, offset): ...
def match_link_label(string, offset, root: Incomplete | None = ...): ...
def get_link_label(text, root): ...
def normalize_label(text): ...
def next_closer(curr_pos, delimiters): ...
def matching_opener(curr_pos, delimiters, bottom): ...
def is_opener(start, end, string): ...
def is_closer(start, end, string): ...
def is_left_delimiter(start, end, string): ...
def is_right_delimiter(start, end, string): ...
def preceded_by(start, string, charset): ...
def succeeded_by(end, string, charset): ...
def is_control_char(char): ...
def follows(string, index, char): ...
def shift_whitespace(string, index): ...
def deactivate_delimiters(delimiters, index, delimiter_type) -> None: ...

class Delimiter:
    type: Incomplete
    number: Incomplete
    active: bool
    start: Incomplete
    end: Incomplete
    open: Incomplete
    close: Incomplete
    def __init__(self, start, end, string) -> None: ...
    def remove(self, n, left: bool = ...): ...
    def closed_by(self, other): ...

class MatchObj:
    fields: Incomplete
    def __init__(self, start, end, *fields) -> None: ...
    def start(self, n: int = ...): ...
    def end(self, n: int = ...): ...
    def group(self, n: int = ...): ...
