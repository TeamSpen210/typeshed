import re
from typing import Container, TypeAlias

from block_token import Document

whitespace: set[str]
unicode_whitespace: set[str]
unicode_chrs: set[str]
punctuation: set[str]
code_pattern: re.Pattern[str]

_StartEndMatch: TypeAlias = tuple[int, int, str]
_DestTitle: TypeAlias = tuple[str, str]

def find_core_tokens(string: str, root) -> list[MatchObj]: ...
def find_link_image(
    string: str, offset: int, delimiters: list[Delimiter], matches: list[MatchObj], root: Document | None = ...
) -> int: ...
def process_emphasis(string: str, stack_bottom, delimiters: list[Delimiter], matches: list[MatchObj]) -> None: ...
def match_link_image(string: str, offset: int, delimiter: list[Delimiter], root: Document | None = ...): ...
def match_link_dest(string: str, offset: int) -> _StartEndMatch | None: ...
def match_link_title(string: str, offset: int) -> _StartEndMatch | None: ...
def match_link_label(string: str, offset: int, root: Document | None = None) -> tuple[_StartEndMatch, _DestTitle] | None: ...
def get_link_label(text: str, root: Document) -> _DestTitle | None: ...
def normalize_label(text: str) -> str: ...
def next_closer(curr_pos: int, delimiters: list[Delimiter]) -> int | None: ...
def matching_opener(curr_pos: int, delimiters: list[Delimiter], bottom: int) -> int | None: ...
def is_opener(start: int, end: int, string: str) -> bool: ...
def is_closer(start: int, end: int, string: str) -> bool: ...
def is_left_delimiter(start: str, end: int, string: str) -> bool: ...
def is_right_delimiter(start: int, end: int, string: str) -> bool: ...
def preceded_by(start: int, string: str, charset: Container[str]) -> bool: ...
def succeeded_by(end: int, string: str, charset: Container[str]) -> bool: ...
def is_control_char(char: str) -> bool: ...
def follows(string: str, index: int, char: str) -> bool: ...
def shift_whitespace(string: str, index: int) -> int: ...
def deactivate_delimiters(delimiters: list[Delimiter], index: int, delimiter_type: str) -> None: ...

class Delimiter:
    type: str
    number: int
    active: bool
    start: int
    end: int
    open: bool
    close: bool
    def __init__(self, start: int, end: int, string: str) -> None: ...
    def remove(self, n: int, left: bool = True) -> bool: ...
    def closed_by(self, other: Delimiter) -> bool: ...

class MatchObj:
    fields: tuple[_StartEndMatch, ...]
    def __init__(self, start, end, *fields: _StartEndMatch) -> None: ...
    def start(self, n: int = 0) -> int: ...
    def end(self, n: int = 0) -> int: ...
    def group(self, n: int = 0) -> str: ...
